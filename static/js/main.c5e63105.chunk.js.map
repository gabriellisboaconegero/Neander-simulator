{"version":3,"sources":["NeanderCoreContext.tsx","styles/index.ts","hooks/useNeader.ts","hooks/useValidAddr.ts","components/styles/index.ts","components/ControlPanel.tsx","components/Instructions.tsx","hooks/useMnemonico.ts","components/Memory/styles.ts","components/Memory/MemoryCell.tsx","components/Memory/Memory.tsx","components/Memory/MemoryControl.tsx","hooks/useBitComplement.ts","App.tsx","index.tsx"],"names":["OpType","GlobalStyles","createGlobalStyle","PageWrapper","styled","div","MNEMONICOS","0","op","op_type","UNARY","16","BINARY","32","48","64","80","96","128","144","160","240","NeanderContext","createContext","NeanderCoreContext","children","useState","pc","setPc","ac","setAc","mem","Array","i","length","value","type","memory","setMemory","colocarSinal","flagN","setFlagN","flagZ","setFlagZ","halt","setHalt","maxDepth","depth","setDepth","number","upDateAc","stateChangerOrPrev","bitComplement","stateChanger","prevState","step","localPc","op_name","next_op","prev","console","log","updateMem","op_load","addr","op_add","op_and","size","newValue","pos","ADDR","useEffect","contextValues","setNewAc","changeMemoryType","new_type","zerarPc","run","Provider","useNeander","useContext","useValidAddr","e","nativeEvent","parseInt","target","data","isNaN","MainWrapper","main","InstructionsWrapper","ul","ControlPanelWrapper","FieldsetStyled","fieldset","AcPanel","PanelBlocksFontStyle","FlagsPanel","ControlsPanel","NumberInBox","span","MemoryWrapper","MemoryStyled","table","ControlPanel","setAddr","isValidAddr","className","onClick","onSubmit","preventDefault","name","id","placeholder","autoComplete","onFocus","select","onChange","toString","padStart","Instructions","Object","entries","map","op_code","useMnemonico","MemoryCellWrapper","tr","props","selecting","css","MemoryCell","mem_data","showOP","showP","selected","mnemonicoParser","Memory","MemoryControl","instructionAddr","setInstructionAddr","setSelecting","setSelected","useBitComplement","handleClickOnMemoryCell","String","inputRef","current","focus","useRef","onBlur","onKeyDown","ev","key","ref","onLoad","App","process","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c5e63105.chunk.js","sourcesContent":["import React, { createContext, useEffect, useState } from \"react\";\nimport { PageWrapper } from \"./styles\";\n\nexport enum OpType {\n  BINARY,\n  UNARY,\n  ADDR\n}\n\nexport type MnemonicoType = {\n  [x: number]: {\n    op: string,\n    op_type: OpType\n  }\n}\n\nexport type MemoryCellType = {\n  value: number,\n  type: OpType\n}\n\n\nexport const MNEMONICOS: MnemonicoType = {\n  0:{\n   op: \"NOP\",\n   op_type: OpType.UNARY\n  },\n  16:{\n   op: \"STA\",\n   op_type: OpType.BINARY\n  },\n  32:{\n   op: \"LDA\",\n   op_type: OpType.BINARY\n  },\n  48:{\n   op: \"ADD\",\n   op_type: OpType.BINARY\n  },\n  64:{\n   op: \"OR\",\n   op_type: OpType.BINARY\n  },\n  80:{\n   op: \"AND\",\n   op_type: OpType.BINARY\n  },\n  96:{\n   op: \"NOT\",\n   op_type: OpType.UNARY\n  },\n  128:{\n   op: \"JMP\",\n   op_type: OpType.BINARY\n  },\n  144:{\n   op: \"JN\",\n   op_type: OpType.BINARY\n  },\n  160:{\n   op: \"JZ\",\n   op_type: OpType.BINARY\n  },\n  240:{\n   op: \"HLT\",\n   op_type: OpType.UNARY\n  }\n}\n\ntype NeanderContextType = {\n  ac: number;\n  pc: number;\n  memory: MemoryCellType[];\n  flagN: boolean;\n  flagZ: boolean;\n  colocarSinal: (number: number) => number;\n  step: () => void;\n  op_load: (addr: number) => void;\n  setNewAc: (value: number) => void;\n  changeMemoryType: (addr: number, new_type: OpType) => void;\n  updateMem: (addr: number, value: number) => void;\n  zerarPc: () => void;\n  run: () => void\n  bitComplement: (value: number, size: number) => number;\n}\n\nexport const NeanderContext = createContext<NeanderContextType>({} as NeanderContextType);\n\nexport const NeanderCoreContext: React.FC = ({children}) => {\n\n  const [pc, setPc] = useState(0);\n  const [ac, setAc] = useState(0);\n  const [memory, setMemory] = useState(() => {\n    const mem = new Array<MemoryCellType>(256);\n    for (let i = 0; i < mem.length; i++) {\n      mem[i] = {\n        value: 0,\n        type: OpType.UNARY\n      }\n    }\n    return mem;\n  });\n  const [flagN, setFlagN] = useState(colocarSinal(ac) < 0);\n  const [flagZ, setFlagZ] = useState(ac === 0);\n\n  const [halt, setHalt] = useState(true);\n  const [maxDepth, setMaxDepth] = useState(300);\n  const [depth, setDepth] = useState(0);\n\n  useEffect(() => {\n    setFlagN(colocarSinal(ac) < 0);\n    setFlagZ(ac === 0);\n  }, [ac]);\n\n  useEffect(() => {\n    if(!halt && pc < memory.length && depth <= maxDepth){\n      step();\n      console.log(\"Dando um passo\", depth);\n    }else if(pc >= memory.length ||  depth > maxDepth){\n      setHalt(true);\n    }\n  }, [halt, pc]);\n\n  function colocarSinal(number: number): number{\n    return number >= 128? -(memory.length - number): number\n  }\n\n  function changeMemoryType(addr: number, new_type: OpType){\n    memory[addr].type = new_type;\n  }\n\n  function upDateAc(stateChangerOrPrev: React.SetStateAction<number>){\n    if (typeof stateChangerOrPrev === \"number\"){\n      stateChangerOrPrev = bitComplement(stateChangerOrPrev);\n      setAc(stateChangerOrPrev);\n    }else{     \n      let stateChanger = stateChangerOrPrev;\n      setAc(prevState => bitComplement(stateChanger(bitComplement(prevState))));\n    }\n  }\n\n  function run(){\n    setHalt(false);\n  }\n\n  function step(){\n    let localPc = pc;\n    let op = memory[localPc];\n    let op_name = MNEMONICOS[(memory[localPc].value >> 4) << 4] || MNEMONICOS[0];\n    let next_op = memory[localPc + 1];\n    if (op.type === OpType.BINARY){\n      localPc += 2\n    }else{\n      localPc += 1;\n    }\n    setDepth(prev => prev + 1);\n\n    switch (op_name.op) {\n      case \"NOP\":\n        console.log(\"Não fez nada\")\n        break;\n      case \"STA\":\n        op_sta(next_op.value);\n        break;\n      case \"LDA\":\n        op_load(next_op.value);\n        break;\n      case \"ADD\":\n        op_add(next_op.value);\n        break;\n      case \"OR\":\n        op_or(next_op.value);\n        break;\n      case \"AND\":\n        op_and(next_op.value);\n        break;\n      case \"NOT\":\n        op_not();\n        break;\n      case \"JMP\":\n        localPc = next_op.value\n        break;\n      case \"JN\":\n        if (flagN) localPc = next_op.value\n        break;\n      case \"JZ\":\n        if (flagZ) localPc = next_op.value\n        break;\n      case \"HLT\":\n        op_hlt();\n        break;\n    \n      default:\n        break;\n    }\n    if (pc < memory.length){\n      setPc(localPc);\n    }\n  }\n\n  function op_load(addr: number){\n    upDateAc(memory[addr].value);\n  }\n\n  function op_sta(addr: number){\n    updateMem(addr, ac);\n  }\n\n  function op_add(addr: number){\n    upDateAc(prev => prev + memory[addr].value);\n  }\n\n  function op_or(value: number){\n    upDateAc(prev => prev | value);\n  }\n\n  function op_and(value: number){\n    upDateAc(prev => prev & value);\n  }\n\n  function op_not(){\n    upDateAc(prev => ~prev);\n  }\n\n  // function op_jmp(addr: number){   just to know that they are operations\n  //   setPc(addr);\n  // }\n\n  // function op_jn(addr: number){\n  //   if (flagN){\n  //     setPc(addr);\n  //   }\n  // }\n\n  // function op_jz(addr: number){\n  //   if (flagZ){\n  //     setPc(addr);\n  //   }\n  // }\n\n  function op_hlt(){\n    setHalt(true);\n  }\n\n  function setNewAc(value: number){\n    upDateAc(value);\n  }\n\n  function zerarPc(){\n    setPc(0);\n  }\n\n  function bitComplement(value: number, size: number=8){\n    size = 2**size;\n    if (value < 0){\n      value = size + value;\n    }\n    return value & (size - 1);\n  }\n\n  function updateMem(addr: number, newValue: number){\n    newValue = bitComplement(newValue);\n    addr = bitComplement(addr);\n    setMemory(prev => {\n      prev[addr].value = newValue;\n      for (let pos=addr; pos < prev.length; pos++){\n        const op = MNEMONICOS[(prev[pos].value >> 4) << 4] || MNEMONICOS[0];\n        if (pos === 0){\n          prev[pos].type = op.op_type\n        }else{\n          const prev_mem = prev[pos - 1];\n          if(prev_mem.type === OpType.BINARY){\n            prev[pos].type = OpType.ADDR\n          }else{\n            prev[pos].type = op.op_type\n          }\n        }\n        if (prev[pos].type === OpType.BINARY || pos === addr){\n          continue;\n        }\n        break\n      }\n      return [...prev]\n    });\n  }\n\n  const contextValues: NeanderContextType = {\n    ac,\n    flagN,\n    flagZ,\n    memory,\n    pc,\n    colocarSinal,\n    op_load,\n    step,\n    setNewAc,\n    changeMemoryType,\n    updateMem,\n    zerarPc,\n    run,\n    bitComplement\n  }\n  return(\n    <NeanderContext.Provider value={contextValues} >\n      <PageWrapper>\n        {children}\n      </PageWrapper>\n    </NeanderContext.Provider >\n  );\n}","import styled, {createGlobalStyle} from \"styled-components\";\n\nexport const GlobalStyles = createGlobalStyle`\n  *{\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n  }\n\n  body{\n    background: #EBEBEB;\n    color: #363636;\n  }\n\n  button{\n    padding: 4px 10px;\n    cursor: pointer;\n    border: 1px solid #363636;\n    border-radius: 2px;\n\n    &:hover{\n      background-color: #D6D6D6;\n    }\n  }\n`\n\nexport const PageWrapper = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  width: 100vw;\n  height: 100vh;\n\n  padding: 40px 0;\n\n  h1{\n    padding: 20px;\n  }\n  /* gap: 16px; */\n`","import { useContext } from \"react\";\nimport { NeanderContext } from \"../NeanderCoreContext\";\n\nexport const useNeander = () => {\n  return useContext(NeanderContext)\n}","import { ChangeEvent } from \"react\";\n\nexport default function useValidAddr(){\n\n  return (e: ChangeEvent<HTMLInputElement>) => {\n    let nativeEvent = e.nativeEvent as InputEvent\n    const value = parseInt(e.target.value);\n    // ------- Se o evento é do tipo input -------\n    if (nativeEvent.type === \"input\"){\n      // -------- Se for backspace ou o caratere `-` --------\n      if (nativeEvent.data === null || nativeEvent.data === \"-\"){\n        return true;\n        // -------- Se o valor de value é NaN ------------\n      }\n      if ( !isNaN(value) ){\n        // --------- Se o caractere passado for um numero -----------\n        if (!isNaN(parseInt(nativeEvent.data))){\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\n","import styled from \"styled-components\";\n// -------- Main -------------\nexport const MainWrapper = styled.main`\n  display: flex;\n  /* align-items: flex-start; */\n  align-content: flex-start;\n  justify-content: center;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n  gap: 10px;\n  flex-wrap: wrap;\n  padding: 0 24px;\n\n  & > *{\n    flex: 3;\n    flex-basis: 50%;\n    align-self: center;\n  }\n`\n\n// ------- Instructions -----\n\nexport const InstructionsWrapper = styled.ul`\n  flex: 1;\n  width: 350px;\n  border: 5px solid #363636;\n  border-radius: 16px;\n\n  list-style: none;\n  padding: 8px;\n\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n\n  li{\n    flex: 1;\n    flex-basis: 25%;\n    text-align: center;\n    padding: 5px 0;\n  }\n`\n\n// ------- Control Panel ------\n\nexport const ControlPanelWrapper = styled.div`\n  width: 60%;\n  max-width: 300px;\n  fieldset{\n    padding: 10px 16px;\n  }\n`\n\nexport const FieldsetStyled = styled.fieldset`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  gap: 10px;\n`\n\nexport const AcPanel = styled(FieldsetStyled)`\n  .acValues{\n    width: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 16px;\n\n    button{\n      align-self: flex-end;\n      padding: 4px 10px;\n      cursor: pointer;\n    }\n  }\n\n  .setAc{\n    input{\n      margin-right: 16px;\n    }\n  }\n`\n\nconst PanelBlocksFontStyle = `\n  font-size: 20px;\n  font-weight: 600;\n`\n\nexport const FlagsPanel = styled(FieldsetStyled)`\n  flex-direction: row;\n  gap: 12px;\n  justify-content: space-evenly;\n\n  span{\n    width: 60px;\n    aspect-ratio: 1;\n    text-align: center;\n    line-height: 60px;\n    color: white;\n    background-color: red;\n\n    border-radius: 50%;\n    border: 3px inset #363636;\n    ${PanelBlocksFontStyle}\n\n    &.active{\n      background-color: green;\n    }\n  }\n`\n\nexport const ControlsPanel = styled(FieldsetStyled)`\n  flex-direction: row;\n  justify-content: flex-start;\n  gap: 12px;\n`\n\nexport const NumberInBox = styled.span`\n  ${PanelBlocksFontStyle}\n  padding: 14px;\n  border: 2px groove threedface;\n`\n\n// ----------- Memory ------------\n\nexport const MemoryWrapper = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n  justify-content: center;\n  width: 600px;\n  height: 100%;\n\n  form, .just_see{\n    flex: 1;\n    flex-basis: 100%;\n    display: flex;\n    flex-direction: column;\n    justify-content: flex-start;\n  }\n\n  .just_see{\n    flex-basis: 40%;\n  }\n`\n\nexport const MemoryStyled = styled.table`\n  display: block;\n  /* flex: 1; */\n  flex-basis: 70%;\n  /* align-self: stretch; */\n  height: 350px;\n  overflow: auto;\n`","import React, { ChangeEvent, FormEvent, useState } from 'react';\nimport { useNeander } from '../hooks/useNeader';\nimport useValidAddr from '../hooks/useValidAddr';\nimport { AcPanel, ControlPanelWrapper, ControlsPanel, FlagsPanel, NumberInBox, FieldsetStyled } from './styles';\n\nexport const ControlPanel: React.FC = () => {\n  const {\n    pc,\n    ac,\n    colocarSinal,\n    flagN,\n    flagZ,\n    step,\n    setNewAc,\n    zerarPc,\n    run\n  } = useNeander();\n  const [addr, setAddr] = useState(\"\");\n  const isValidAddr = useValidAddr();\n\n  function Digit3Number(number: string | number){\n    return number.toString().padStart(3, '0')\n  }\n\n  function handleNewAddrInput(e: ChangeEvent<HTMLInputElement>){\n    if (isValidAddr(e)){\n      setAddr(e.target.value);\n    }\n  }\n\n  function handleSetNewAc(e: FormEvent<HTMLFormElement>){\n    e.preventDefault();\n    setNewAc(parseInt(addr) || 0);\n    setAddr(\"\");\n  }\n\n  return(\n    <ControlPanelWrapper>\n      <AcPanel>\n        <legend>AC:</legend>\n        <div className=\"acValues\">\n          <NumberInBox>{ac}</NumberInBox>\n          <button onClick={e => setNewAc(0)} >Zerar</button>\n          <NumberInBox>{colocarSinal(ac)}</NumberInBox>\n        </div>\n        <form \n          className=\"setAc\"\n          onSubmit={handleSetNewAc}\n        >\n          <input\n            type=\"text\"\n            name=\"set_ac\"\n            id=\"set_ac\"\n            placeholder=\"New AC value[-128, 255]\"\n            autoComplete=\"off\"\n            value={addr}\n            onFocus={e => e.target.select()}\n            onChange={handleNewAddrInput}\n          />\n          <button type=\"submit\">Set</button>\n        </form>\n      </AcPanel>\n      <FieldsetStyled>\n        <legend>PC:</legend>\n        <NumberInBox>{Digit3Number(pc)}</NumberInBox>\n        <button onClick={e => zerarPc()} >Zerar</button>\n      </FieldsetStyled>\n      <FlagsPanel>\n        <legend>Flags:</legend>\n        <span className={`${flagN? \"active\":\"\"}`}>N</span>\n        <span className={`${flagZ? \"active\":\"\"}`}>Z</span>\n      </FlagsPanel>\n      <ControlsPanel>\n        <legend>Controls:</legend>\n        <button onClick={e => step()}>Step</button>\n        <button onClick={e => run()}>Run</button>\n      </ControlsPanel>\n    </ControlPanelWrapper>\n  );\n}","import React from 'react';\nimport { MNEMONICOS } from '../NeanderCoreContext';\nimport { InstructionsWrapper } from './styles';\n\nexport const Instructions: React.FC = () => {\n  return(\n    <InstructionsWrapper>\n      {Object.entries(MNEMONICOS).map(([op_code, op], id) => {\n        return(\n          <li key={`instruction_map_item_${id}`}><strong>{op.op}</strong>: {op_code}</li>\n        )\n      })}\n    </InstructionsWrapper>\n  );\n}","import { MNEMONICOS } from \"../NeanderCoreContext\";\nimport { useNeander } from \"./useNeader\";\n\nconst useMnemonico = () => {\n  const {memory} = useNeander();\n  return (addr: number ) => {\n    return MNEMONICOS[(memory[addr].value >> 4) << 4] || MNEMONICOS[0];\n  }\n}\n\nexport default useMnemonico;","import styled, { css } from \"styled-components\";\n\nexport const MemoryCellWrapper  = styled.tr<{selecting: boolean}>`\n  ${props => {\n    if (props.selecting){\n      return css`\n        background-color: lightblue;\n      `\n    }\n  }}\n`","import React, { AllHTMLAttributes } from 'react';\nimport { MemoryCellType, OpType } from '../../NeanderCoreContext';\nimport useMnemonico from '../../hooks/useMnemonico';\nimport { useNeander } from '../../hooks/useNeader';\nimport { MemoryCellWrapper } from './styles';\n\ntype Props = AllHTMLAttributes<HTMLElement> & {\n  addr: number;\n  mem_data: MemoryCellType;\n  showP?: boolean;\n  showOP?: boolean;\n  selecting: boolean\n}\n\nexport const MemoryCell: React.FC<Props> = ({\n  addr,\n  mem_data,\n  showOP,\n  showP,\n  selected,\n  selecting,\n  onClick,\n}) => {\n  const mnemonicoParser = useMnemonico();\n  const {pc, memory} = useNeander();\n\n  return(\n    <MemoryCellWrapper onClick={onClick} selecting={selected && selecting? true : false}>\n      {showP && <td>{pc === addr && \">\"}</td>}\n      <td>{addr}</td>\n      <td>{mem_data.value}</td>\n      {showOP && \n        <td>\n          {mem_data.type === OpType.ADDR? \"\" : (\n            <>\n              <span>{mnemonicoParser(addr).op} &nbsp;</span>\n              {mem_data.type === OpType.BINARY && addr < memory.length && <span>{memory[addr + 1].value}</span>}\n            </>\n          )}\n        </td>\n      }\n    </MemoryCellWrapper>\n  );\n}","import React from 'react';\nimport { useNeander } from '../../hooks/useNeader';\nimport { MemoryStyled } from '../styles';\nimport { MemoryCell } from './MemoryCell';\n\ntype Props = {\n  showOP?: boolean;\n  showP?: boolean;\n  selected: number;\n  selecting: boolean;\n  onClick?: (addr: number)  => void;\n}\n\nexport const Memory: React.FC<Props> = ({showOP, showP, selecting, selected, onClick}) => {\n  const {\n    memory,\n  }  = useNeander();\n\n  return (\n    <MemoryStyled>\n      <thead>\n        <tr>\n          {showP && <th>P</th>}\n          <th>Address</th>\n          <th>Data</th>\n          {showOP && <th>Operation</th>}\n        </tr>\n      </thead>\n      <tbody>\n        {memory.map((data, addr) => {\n          return(\n            <MemoryCell \n              key={`${addr}_${data.value}`} \n              mem_data={data} \n              addr={addr}\n              selected={selected === addr}\n              selecting={selecting}\n              showP={showP} \n              showOP={showOP}\n              onClick={e => onClick?.(addr)}\n            />\n          )\n        })}\n      </tbody>\n    </MemoryStyled>\n  );\n}","import React, { ChangeEvent, FormEvent, KeyboardEvent, useEffect, useRef, useState } from 'react';\nimport useBitComplement from '../../hooks/useBitComplement';\nimport { useNeander } from '../../hooks/useNeader';\nimport useValidAddr from '../../hooks/useValidAddr';\nimport { MemoryWrapper } from '../styles';\nimport { Memory } from './Memory';\n\n\nexport const MemoryControl: React.FC = () => {\n  const {\n    memory,\n    updateMem,\n  }  = useNeander();\n\n  const [instructionAddr, setInstructionAddr] = useState(\"\");\n  const [selecting, setSelecting] = useState(false);\n  const [selected, setSelected] = useState(0);\n  const isValidAddr = useValidAddr();\n  const bitComplement = useBitComplement();\n\n  useEffect(() => {\n    inputRef.current?.focus();\n    inputRef.current?.select();\n  }, [selected]);\n\n  function handleKeyDown(this: HTMLElement, ev: KeyboardEvent){\n    \n    switch (ev.key) {\n      case \"ArrowDown\":\n        handleClickOnMemoryCell(bitComplement(selected + 1));\n        ev.preventDefault();\n        break;\n\n      case \"ArrowUp\":\n        handleClickOnMemoryCell(bitComplement(selected - 1));\n        ev.preventDefault();\n        break;\n    \n      default:\n        break;\n    }\n  }\n\n  function handleClickOnMemoryCell(addr: number){\n    setSelected(addr);\n    setInstructionAddr(String(memory[addr].value));\n    inputRef.current?.focus();\n    inputRef.current?.select();\n    if (selecting) return;\n    setSelecting(true);\n  }\n\n  function handleNewInstructionInput(e: ChangeEvent<HTMLInputElement>){\n    if (isValidAddr(e)){\n      setInstructionAddr(e.target.value);\n    }\n  }\n\n  function  handlePushNewInstructionToMem(e: FormEvent<HTMLFormElement>){\n    e.preventDefault();\n    handleClickOnMemoryCell(selected + 1);\n    updateMem(selected, parseInt(instructionAddr) || 0)\n  }\n  const inputRef = useRef<HTMLInputElement>(null);\n  \n  return(\n    <MemoryWrapper>\n      <form\n        onSubmit={handlePushNewInstructionToMem}\n      >\n        <Memory\n          selected={selected}\n          selecting={selecting}\n          showOP\n          showP\n          onClick={handleClickOnMemoryCell}\n        />\n        <input\n          onBlur={e => {\n            setSelecting(false)\n          }}\n          onKeyDown={handleKeyDown}\n          ref={inputRef}\n          name=\"teste2\"\n          id=\"teste2\"\n          value={instructionAddr}\n          onChange={handleNewInstructionInput}\n          type=\"text\"\n          placeholder=\"Instruction nº[-128, 255]\"\n          autoComplete=\"off\"\n          onFocus={e => e.target.select()}\n          onLoad={e => console.log(e)}\n          onClick={e => handleClickOnMemoryCell(selected)}\n        />\n        <button type=\"submit\">Set mem</button>\n      </form>\n      <div className=\"just_see\">\n        <Memory\n          selected={selected}\n          selecting={selecting}\n          onClick={handleClickOnMemoryCell}\n        />\n      </div>\n    </MemoryWrapper>\n\n  );\n}","import { useNeander } from \"./useNeader\"\n\nexport default function useBitComplement(size: number=8){\n  const {bitComplement} = useNeander();\n  return (value: number) => {\n    return bitComplement(value, size);\n  }\n}","import React from 'react';\nimport { ControlPanel } from './components/ControlPanel';\nimport { Instructions } from './components/Instructions';\nimport { MemoryControl } from './components/Memory/MemoryControl';\nimport { MainWrapper } from './components/styles';\nimport { NeanderCoreContext } from './NeanderCoreContext';\nimport { GlobalStyles } from './styles';\n\nconst App: React.FC = () => {\n  const version = process.env.REACT_APP_VERSION\n  return(\n    <NeanderCoreContext>\n      <GlobalStyles />\n      <h1>Neander Simulator Version {version}</h1>\n      <MainWrapper>\n        <Instructions />\n        <ControlPanel />\n        <MemoryControl />\n      </MainWrapper>\n    </NeanderCoreContext>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}