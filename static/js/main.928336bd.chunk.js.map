{"version":3,"sources":["NeanderCoreContext.tsx","styles/index.ts","hooks/useNeader.ts","hooks/useValidAddr.ts","components/styles/index.ts","components/ControlPanel.tsx","components/Instructions.tsx","hooks/useMnemonico.ts","components/Memory/styles.ts","components/Memory/MemoryCell.tsx","components/Memory/Memory.tsx","components/Memory/MemoryControl.tsx","hooks/useBitComplement.ts","App.tsx","index.tsx"],"names":["OpType","GlobalStyles","createGlobalStyle","PageWrapper","styled","div","MNEMONICOS","0","op","op_type","UNARY","16","BINARY","32","48","64","80","96","128","144","160","240","NeanderContext","createContext","NeanderCoreContext","children","useState","pc","setPc","ac","setAc","mem","Array","i","length","value","type","memory","setMemory","colocarSinal","flagN","setFlagN","flagZ","setFlagZ","halt","setHalt","maxDepth","depth","setDepth","number","upDateAc","stateChangerOrPrev","bitComplement","stateChanger","prevState","step","localPc","op_name","next_op","prev","console","log","updateMem","op_load","addr","op_add","op_and","size","setMem","newValue","pos","ADDR","useEffect","contextValues","setNewAc","changeMemoryType","new_type","zerarPc","run","downloadMem","memText","forEach","id","opeartionStr","blob","Blob","fileDowloadUrl","URL","createObjectURL","downloadElment","document","createElement","href","download","body","appendChild","click","setTimeout","revokeObjectURL","removeChild","shiftMem","addrToShift","shiftDirection","tempMem","map","e","Provider","useNeander","useContext","useValidAddr","nativeEvent","parseInt","target","data","isNaN","MainWrapper","main","InstructionsWrapper","ul","ControlPanelWrapper","FieldsetStyled","fieldset","AcPanel","PanelBlocksFontStyle","FlagsPanel","ControlsPanel","NumberInBox","span","MemoryWrapper","MemoryStyled","table","ControlPanel","setAddr","isValidAddr","className","onClick","onSubmit","preventDefault","name","placeholder","autoComplete","onFocus","select","onChange","toString","padStart","Instructions","Object","entries","op_code","useMnemonico","MemoryCellWrapper","tr","props","selecting","css","MemoryCell","mem_data","showOP","showP","selected","mnemonicoParser","Memory","MemoryControl","instructionAddr","setInstructionAddr","setSelecting","setSelected","useBitComplement","handleClickOnMemoryCell","String","inputRef","current","focus","useRef","onBlur","onKeyDown","ev","key","ref","App","process","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.928336bd.chunk.js","sourcesContent":["import React, { createContext, memo, useEffect, useState } from \"react\";\nimport { PageWrapper } from \"./styles\";\n\nexport enum OpType {\n  BINARY,\n  UNARY,\n  ADDR\n}\n\nexport type MnemonicoType = {\n  [x: number]: {\n    op: string,\n    op_type: OpType\n  }\n}\n\nexport type MemoryCellType = {\n  value: number,\n  type: OpType\n}\n\n\nexport const MNEMONICOS: MnemonicoType = {\n  0:{\n   op: \"NOP\",\n   op_type: OpType.UNARY\n  },\n  16:{\n   op: \"STA\",\n   op_type: OpType.BINARY\n  },\n  32:{\n   op: \"LDA\",\n   op_type: OpType.BINARY\n  },\n  48:{\n   op: \"ADD\",\n   op_type: OpType.BINARY\n  },\n  64:{\n   op: \"OR\",\n   op_type: OpType.BINARY\n  },\n  80:{\n   op: \"AND\",\n   op_type: OpType.BINARY\n  },\n  96:{\n   op: \"NOT\",\n   op_type: OpType.UNARY\n  },\n  128:{\n   op: \"JMP\",\n   op_type: OpType.BINARY\n  },\n  144:{\n   op: \"JN\",\n   op_type: OpType.BINARY\n  },\n  160:{\n   op: \"JZ\",\n   op_type: OpType.BINARY\n  },\n  240:{\n   op: \"HLT\",\n   op_type: OpType.UNARY\n  }\n}\n\ntype NeanderContextType = {\n  ac: number;\n  pc: number;\n  memory: MemoryCellType[];\n  flagN: boolean;\n  flagZ: boolean;\n  colocarSinal: (number: number) => number;\n  step: () => void;\n  op_load: (addr: number) => void;\n  setNewAc: (value: number) => void;\n  changeMemoryType: (addr: number, new_type: OpType) => void;\n  updateMem: (addr: number, value: number) => void;\n  zerarPc: () => void;\n  run: () => void;\n  bitComplement: (value: number, size: number) => number;\n  downloadMem: () => void;\n  shiftMem: (addrToShift: number, shiftDirection: number) => void;\n}\n\nexport const NeanderContext = createContext<NeanderContextType>({} as NeanderContextType);\n\nexport const NeanderCoreContext: React.FC = ({children}) => {\n\n  const [pc, setPc] = useState(0);\n  const [ac, setAc] = useState(0);\n  const [memory, setMemory] = useState(() => {\n    const mem = new Array<MemoryCellType>(256);\n    for (let i = 0; i < mem.length; i++) {\n      mem[i] = {\n        value: 0,\n        type: OpType.UNARY\n      }\n    }\n    return mem;\n  });\n  const [flagN, setFlagN] = useState(colocarSinal(ac) < 0);\n  const [flagZ, setFlagZ] = useState(ac === 0);\n\n  const [halt, setHalt] = useState(true);\n  const [maxDepth, setMaxDepth] = useState(300);\n  const [depth, setDepth] = useState(0);\n\n  useEffect(() => {\n    setFlagN(colocarSinal(ac) < 0);\n    setFlagZ(ac === 0);\n  }, [ac]);\n\n  useEffect(() => {\n    if(!halt && pc < memory.length && depth <= maxDepth){\n      step();\n      console.log(\"Dando um passo\", depth);\n    }else if(pc >= memory.length ||  depth > maxDepth){\n      setHalt(true);\n    }\n  }, [halt, pc]);\n\n  function colocarSinal(number: number): number{\n    return number >= 128? -(memory.length - number): number\n  }\n\n  function changeMemoryType(addr: number, new_type: OpType){\n    memory[addr].type = new_type;\n  }\n\n  function upDateAc(stateChangerOrPrev: React.SetStateAction<number>){\n    if (typeof stateChangerOrPrev === \"number\"){\n      stateChangerOrPrev = bitComplement(stateChangerOrPrev);\n      setAc(stateChangerOrPrev);\n    }else{     \n      let stateChanger = stateChangerOrPrev;\n      setAc(prevState => bitComplement(stateChanger(bitComplement(prevState))));\n    }\n  }\n\n  function run(){\n    setHalt(false);\n  }\n\n  function step(){\n    let localPc = pc;\n    let op = memory[localPc];\n    let op_name = MNEMONICOS[(memory[localPc].value >> 4) << 4] || MNEMONICOS[0];\n    let next_op = memory[localPc + 1];\n    if (op.type === OpType.BINARY){\n      localPc += 2\n    }else{\n      localPc += 1;\n    }\n    setDepth(prev => prev + 1);\n\n    switch (op_name.op) {\n      case \"NOP\":\n        console.log(\"Não fez nada\")\n        break;\n      case \"STA\":\n        op_sta(next_op.value);\n        break;\n      case \"LDA\":\n        op_load(next_op.value);\n        break;\n      case \"ADD\":\n        op_add(next_op.value);\n        break;\n      case \"OR\":\n        op_or(next_op.value);\n        break;\n      case \"AND\":\n        op_and(next_op.value);\n        break;\n      case \"NOT\":\n        op_not();\n        break;\n      case \"JMP\":\n        localPc = next_op.value\n        break;\n      case \"JN\":\n        if (flagN) localPc = next_op.value\n        break;\n      case \"JZ\":\n        if (flagZ) localPc = next_op.value\n        break;\n      case \"HLT\":\n        op_hlt();\n        break;\n    \n      default:\n        break;\n    }\n    if (pc < memory.length){\n      setPc(localPc);\n    }\n  }\n\n  function op_load(addr: number){\n    upDateAc(memory[addr].value);\n  }\n\n  function op_sta(addr: number){\n    updateMem(addr, ac);\n  }\n\n  function op_add(addr: number){\n    upDateAc(prev => prev + memory[addr].value);\n  }\n\n  function op_or(value: number){\n    upDateAc(prev => prev | value);\n  }\n\n  function op_and(value: number){\n    upDateAc(prev => prev & value);\n  }\n\n  function op_not(){\n    upDateAc(prev => ~prev);\n  }\n\n  // function op_jmp(addr: number){   just to know that they are operations\n  //   setPc(addr);\n  // }\n\n  // function op_jn(addr: number){\n  //   if (flagN){\n  //     setPc(addr);\n  //   }\n  // }\n\n  // function op_jz(addr: number){\n  //   if (flagZ){\n  //     setPc(addr);\n  //   }\n  // }\n\n  function op_hlt(){\n    setHalt(true);\n  }\n\n  function setNewAc(value: number){\n    upDateAc(value);\n  }\n\n  function zerarPc(){\n    setPc(0);\n  }\n\n  function bitComplement(value: number, size: number=8){\n    size = 2**size;\n    if (value < 0){\n      value = size + value;\n    }\n    return value & (size - 1);\n  }\n\n  function shiftMem(addrToShift: number, shiftDirection: number){\n    if (addrToShift === memory.length - 1 || memory[addrToShift].type === OpType.BINARY){\n      return;\n    }\n    setMemory(prev => {\n      const tempMem = prev.map(e => e);\n\n      tempMem[addrToShift + 1] = {\n        value: 0,\n        type: OpType.UNARY\n      }\n      for (let pos = addrToShift + 2;  pos < memory.length;  pos++){\n        tempMem[pos] = prev[pos - 1];\n      }\n      return setMem(0, tempMem[0].value, tempMem);\n    });\n  }\n\n  function setMem(addr: number, newValue: number, prev: MemoryCellType[]){\n    prev[addr].value = newValue;\n    for (let pos = addr; pos < prev.length; pos++){\n      const op = MNEMONICOS[(prev[pos].value >> 4) << 4] || MNEMONICOS[0];\n      if (pos === 0){\n        prev[pos].type = op.op_type\n      }else{\n        const prev_mem = prev[pos - 1];\n        if(prev_mem.type === OpType.BINARY){\n          prev[pos].type = OpType.ADDR\n        }else{\n          prev[pos].type = op.op_type\n        }\n      }\n      if (prev[pos].type === OpType.BINARY || pos === addr){\n        continue;\n      }\n      break\n    }\n    return prev\n  }\n\n  function updateMem(addr: number, newValue: number){\n    newValue = bitComplement(newValue);\n    addr = bitComplement(addr);\n    setMemory(prev => setMem(addr, newValue, prev));\n  }\n\n  function downloadMem(){\n    let memText = \"\";\n    memory.forEach(({value, type}, id) => {\n      const op = MNEMONICOS[(value >> 4) << 4] || MNEMONICOS[0];\n      let opeartionStr = op.op;\n      if (id < memory.length - 1){\n        if (type === OpType.ADDR){\n          opeartionStr = \"\";\n        }else if (type === OpType.BINARY){\n          opeartionStr += ` ${memory[id + 1].value}`;\n        }\n      }\n      memText += `${id}:${value} ${opeartionStr}\\n`;\n    });\n\n    const blob = new Blob([memText], {type: 'text'});\n    const fileDowloadUrl = URL.createObjectURL(blob);\n    const downloadElment = document.createElement(\"a\");\n    downloadElment.href = fileDowloadUrl;\n    downloadElment.download = \"neander_mem.txt\";\n    document.body.appendChild(downloadElment);\n    downloadElment.click();\n    setTimeout(() => {\n      URL.revokeObjectURL(fileDowloadUrl);\n      document.body.removeChild(downloadElment);\n    }, 0);\n  }\n\n  const contextValues: NeanderContextType = {\n    ac,\n    flagN,\n    flagZ,\n    memory,\n    pc,\n    colocarSinal,\n    op_load,\n    step,\n    setNewAc,\n    changeMemoryType,\n    updateMem,\n    zerarPc,\n    run,\n    bitComplement,\n    downloadMem,\n    shiftMem\n  }\n  return(\n    <NeanderContext.Provider value={contextValues} >\n      <PageWrapper>\n        {children}\n      </PageWrapper>\n    </NeanderContext.Provider >\n  );\n}","import styled, {createGlobalStyle} from \"styled-components\";\n\nexport const GlobalStyles = createGlobalStyle`\n  *{\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n  }\n\n  body{\n    background: #EBEBEB;\n    color: #363636;\n  }\n\n  button{\n    padding: 4px 10px;\n    cursor: pointer;\n    border: 1px solid #363636;\n    border-radius: 2px;\n\n    &:hover{\n      background-color: #D6D6D6;\n    }\n  }\n`\n\nexport const PageWrapper = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  width: 100vw;\n  height: 100vh;\n\n  padding: 40px 0;\n\n  h1{\n    padding: 20px;\n  }\n  /* gap: 16px; */\n`","import { useContext } from \"react\";\nimport { NeanderContext } from \"../NeanderCoreContext\";\n\nexport const useNeander = () => {\n  return useContext(NeanderContext)\n}","import { ChangeEvent } from \"react\";\n\nexport default function useValidAddr(){\n\n  return (e: ChangeEvent<HTMLInputElement>) => {\n    let nativeEvent = e.nativeEvent as InputEvent\n    const value = parseInt(e.target.value);\n    // ------- Se o evento é do tipo input -------\n    if (nativeEvent.type === \"input\"){\n      // -------- Se for backspace ou o caratere `-` --------\n      if (nativeEvent.data === null || nativeEvent.data === \"-\"){\n        return true;\n        // -------- Se o valor de value é NaN ------------\n      }\n      if ( !isNaN(value) ){\n        // --------- Se o caractere passado for um numero -----------\n        if (!isNaN(parseInt(nativeEvent.data))){\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\n","import styled from \"styled-components\";\n// -------- Main -------------\nexport const MainWrapper = styled.main`\n  display: flex;\n  /* align-items: flex-start; */\n  align-content: flex-start;\n  justify-content: center;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n  gap: 10px;\n  flex-wrap: wrap;\n  padding: 0 24px;\n\n  & > *{\n    flex: 3;\n    flex-basis: 50%;\n    align-self: center;\n  }\n`\n\n// ------- Instructions -----\n\nexport const InstructionsWrapper = styled.ul`\n  flex: 1;\n  width: 350px;\n  border: 5px solid #363636;\n  border-radius: 16px;\n\n  list-style: none;\n  padding: 8px;\n\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n\n  li{\n    flex: 1;\n    flex-basis: 25%;\n    text-align: center;\n    padding: 5px 0;\n  }\n`\n\n// ------- Control Panel ------\n\nexport const ControlPanelWrapper = styled.div`\n  width: 60%;\n  max-width: 300px;\n  fieldset{\n    padding: 10px 16px;\n  }\n`\n\nexport const FieldsetStyled = styled.fieldset`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  gap: 10px;\n`\n\nexport const AcPanel = styled(FieldsetStyled)`\n  .acValues{\n    width: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    gap: 16px;\n\n    button{\n      align-self: flex-end;\n      padding: 4px 10px;\n      cursor: pointer;\n    }\n  }\n\n  .setAc{\n    input{\n      margin-right: 16px;\n    }\n  }\n`\n\nconst PanelBlocksFontStyle = `\n  font-size: 20px;\n  font-weight: 600;\n`\n\nexport const FlagsPanel = styled(FieldsetStyled)`\n  flex-direction: row;\n  gap: 12px;\n  justify-content: space-evenly;\n\n  span{\n    width: 60px;\n    aspect-ratio: 1;\n    text-align: center;\n    line-height: 60px;\n    color: white;\n    background-color: red;\n\n    border-radius: 50%;\n    border: 3px inset #363636;\n    ${PanelBlocksFontStyle}\n\n    &.active{\n      background-color: green;\n    }\n  }\n`\n\nexport const ControlsPanel = styled(FieldsetStyled)`\n  flex-direction: row;\n  justify-content: flex-start;\n  gap: 12px;\n`\n\nexport const NumberInBox = styled.span`\n  ${PanelBlocksFontStyle}\n  padding: 14px;\n  border: 2px groove threedface;\n`\n\n// ----------- Memory ------------\n\nexport const MemoryWrapper = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n  justify-content: center;\n  width: 600px;\n  height: 100%;\n\n  form, .just_see{\n    flex: 1;\n    flex-basis: 100%;\n    display: flex;\n    flex-direction: column;\n    justify-content: flex-start;\n  }\n\n  .just_see{\n    flex-basis: 40%;\n  }\n`\n\nexport const MemoryStyled = styled.table`\n  display: block;\n  /* flex: 1; */\n  flex-basis: 70%;\n  /* align-self: stretch; */\n  height: 350px;\n  overflow: auto;\n`","import React, { ChangeEvent, FormEvent, useState } from 'react';\nimport { useNeander } from '../hooks/useNeader';\nimport useValidAddr from '../hooks/useValidAddr';\nimport { AcPanel, ControlPanelWrapper, ControlsPanel, FlagsPanel, NumberInBox, FieldsetStyled } from './styles';\n\nexport const ControlPanel: React.FC = () => {\n  const {\n    pc,\n    ac,\n    colocarSinal,\n    flagN,\n    flagZ,\n    step,\n    setNewAc,\n    zerarPc,\n    run,\n    downloadMem\n  } = useNeander();\n  const [addr, setAddr] = useState(\"\");\n  const isValidAddr = useValidAddr();\n\n  function Digit3Number(number: string | number){\n    return number.toString().padStart(3, '0')\n  }\n\n  function handleNewAddrInput(e: ChangeEvent<HTMLInputElement>){\n    if (isValidAddr(e)){\n      setAddr(e.target.value);\n    }\n  }\n\n  function handleSetNewAc(e: FormEvent<HTMLFormElement>){\n    e.preventDefault();\n    setNewAc(parseInt(addr) || 0);\n    setAddr(\"\");\n  }\n\n  return(\n    <ControlPanelWrapper>\n      <AcPanel>\n        <legend>AC:</legend>\n        <div className=\"acValues\">\n          <NumberInBox>{ac}</NumberInBox>\n          <button onClick={e => setNewAc(0)} >Zerar</button>\n          <NumberInBox>{colocarSinal(ac)}</NumberInBox>\n        </div>\n        <form \n          className=\"setAc\"\n          onSubmit={handleSetNewAc}\n        >\n          <input\n            type=\"text\"\n            name=\"set_ac\"\n            id=\"set_ac\"\n            placeholder=\"New AC value\"\n            autoComplete=\"off\"\n            value={addr}\n            onFocus={e => e.target.select()}\n            onChange={handleNewAddrInput}\n          />\n          <button type=\"submit\">Set</button>\n        </form>\n      </AcPanel>\n      <FieldsetStyled>\n        <legend>PC:</legend>\n        <NumberInBox>{Digit3Number(pc)}</NumberInBox>\n        <button onClick={e => zerarPc()} >Zerar</button>\n      </FieldsetStyled>\n      <FlagsPanel>\n        <legend>Flags:</legend>\n        <span className={`${flagN? \"active\":\"\"}`}>N</span>\n        <span className={`${flagZ? \"active\":\"\"}`}>Z</span>\n      </FlagsPanel>\n      <ControlsPanel>\n        <legend>Controls:</legend>\n        <button onClick={e => step()}>Step</button>\n        <button onClick={e => run()}>Run</button>\n        <button onClick={e => downloadMem()}>Download .txt file</button>\n      </ControlsPanel>\n    </ControlPanelWrapper>\n  );\n}","import React from 'react';\nimport { MNEMONICOS } from '../NeanderCoreContext';\nimport { InstructionsWrapper } from './styles';\n\nexport const Instructions: React.FC = () => {\n  return(\n    <InstructionsWrapper>\n      {Object.entries(MNEMONICOS).map(([op_code, op], id) => {\n        return(\n          <li key={`instruction_map_item_${id}`}><strong>{op.op}</strong>: {op_code}</li>\n        )\n      })}\n    </InstructionsWrapper>\n  );\n}","import { MNEMONICOS } from \"../NeanderCoreContext\";\nimport { useNeander } from \"./useNeader\";\n\nconst useMnemonico = () => {\n  const {memory} = useNeander();\n  return (addr: number ) => {\n    return MNEMONICOS[(memory[addr].value >> 4) << 4] || MNEMONICOS[0];\n  }\n}\n\nexport default useMnemonico;","import styled, { css } from \"styled-components\";\n\nexport const MemoryCellWrapper  = styled.tr<{selecting: boolean}>`\n  ${props => {\n    if (props.selecting){\n      return css`\n        background-color: lightblue;\n      `\n    }\n  }}\n`","import React, { AllHTMLAttributes } from 'react';\nimport { MemoryCellType, OpType } from '../../NeanderCoreContext';\nimport useMnemonico from '../../hooks/useMnemonico';\nimport { useNeander } from '../../hooks/useNeader';\nimport { MemoryCellWrapper } from './styles';\n\ntype Props = AllHTMLAttributes<HTMLElement> & {\n  addr: number;\n  mem_data: MemoryCellType;\n  showP?: boolean;\n  showOP?: boolean;\n  selecting: boolean\n}\n\nexport const MemoryCell: React.FC<Props> = ({\n  addr,\n  mem_data,\n  showOP,\n  showP,\n  selected,\n  selecting,\n  onClick,\n}) => {\n  const mnemonicoParser = useMnemonico();\n  const {pc, memory} = useNeander();\n\n  return(\n    <MemoryCellWrapper onClick={onClick} selecting={selected && selecting? true : false}>\n      {showP && <td>{pc === addr && \">\"}</td>}\n      <td>{addr}</td>\n      <td>{mem_data.value}</td>\n      {showOP && \n        <td>\n          {mem_data.type === OpType.ADDR? \"\" : (\n            <>\n              <span>{mnemonicoParser(addr).op} &nbsp;</span>\n              {mem_data.type === OpType.BINARY && addr < memory.length && <span>{memory[addr + 1].value}</span>}\n            </>\n          )}\n        </td>\n      }\n    </MemoryCellWrapper>\n  );\n}","import React from 'react';\nimport { useNeander } from '../../hooks/useNeader';\nimport { MemoryStyled } from '../styles';\nimport { MemoryCell } from './MemoryCell';\n\ntype Props = {\n  showOP?: boolean;\n  showP?: boolean;\n  selected: number;\n  selecting: boolean;\n  onClick?: (addr: number)  => void;\n}\n\nexport const Memory: React.FC<Props> = ({showOP, showP, selecting, selected, onClick}) => {\n  const {\n    memory,\n  }  = useNeander();\n\n  return (\n    <MemoryStyled>\n      <thead>\n        <tr>\n          {showP && <th>P</th>}\n          <th>Address</th>\n          <th>Data</th>\n          {showOP && <th>Operation</th>}\n        </tr>\n      </thead>\n      <tbody>\n        {memory.map((data, addr) => {\n          return(\n            <MemoryCell \n              key={`${addr}_${data.value}`} \n              mem_data={data} \n              addr={addr}\n              selected={selected === addr}\n              selecting={selecting}\n              showP={showP} \n              showOP={showOP}\n              onClick={e => onClick?.(addr)}\n            />\n          )\n        })}\n      </tbody>\n    </MemoryStyled>\n  );\n}","import React, { ChangeEvent, FormEvent, KeyboardEvent, useEffect, useRef, useState } from 'react';\nimport useBitComplement from '../../hooks/useBitComplement';\nimport { useNeander } from '../../hooks/useNeader';\nimport useValidAddr from '../../hooks/useValidAddr';\nimport { MemoryWrapper } from '../styles';\nimport { Memory } from './Memory';\n\n\nexport const MemoryControl: React.FC = () => {\n  const {\n    memory,\n    updateMem,\n    shiftMem\n  }  = useNeander();\n\n  const [instructionAddr, setInstructionAddr] = useState(\"\");\n  const [selecting, setSelecting] = useState(false);\n  const [selected, setSelected] = useState(0);\n  const isValidAddr = useValidAddr();\n  const bitComplement = useBitComplement();\n\n  useEffect(() => {\n    inputRef.current?.focus();\n    inputRef.current?.select();\n  }, [selected]);\n\n  function handleKeyDown(this: HTMLElement, ev: KeyboardEvent){\n    \n    switch (ev.key) {\n      case \"ArrowDown\":\n        handleClickOnMemoryCell(bitComplement(selected + 1));\n        ev.preventDefault();\n        break;\n\n      case \"ArrowUp\":\n        handleClickOnMemoryCell(bitComplement(selected - 1));\n        ev.preventDefault();\n        break;\n    \n      default:\n        break;\n    }\n  }\n\n  function handleClickOnMemoryCell(addr: number){\n    setSelected(addr);\n    setInstructionAddr(String(memory[addr].value));\n    inputRef.current?.focus();\n    inputRef.current?.select();\n    if (selecting) return;\n    setSelecting(true);\n  }\n\n  function handleNewInstructionInput(e: ChangeEvent<HTMLInputElement>){\n    if (isValidAddr(e)){\n      setInstructionAddr(e.target.value);\n    }\n  }\n\n  function  handlePushNewInstructionToMem(e: FormEvent<HTMLFormElement>){\n    e.preventDefault();\n    handleClickOnMemoryCell(selected + 1);\n    updateMem(selected, parseInt(instructionAddr) || 0)\n  }\n  const inputRef = useRef<HTMLInputElement>(null);\n  \n  return(\n    <MemoryWrapper>\n      <form\n        onSubmit={handlePushNewInstructionToMem}\n      >\n        <Memory\n          selected={selected}\n          selecting={selecting}\n          showOP\n          showP\n          onClick={handleClickOnMemoryCell}\n        />\n        <input\n          onBlur={e => {\n            setSelecting(false)\n          }}\n          onKeyDown={handleKeyDown}\n          ref={inputRef}\n          name=\"teste2\"\n          id=\"teste2\"\n          value={instructionAddr}\n          onChange={handleNewInstructionInput}\n          type=\"text\"\n          placeholder=\"Instruction number\"\n          autoComplete=\"off\"\n          onFocus={e => e.target.select()}\n          onClick={e => handleClickOnMemoryCell(selected)}\n        />\n        <button type=\"button\" onClick={e => shiftMem(selected, 1)}>Add mem line</button>\n        <button type=\"submit\">Set mem</button>\n      </form>\n      <div className=\"just_see\">\n        <Memory\n          selected={selected}\n          selecting={selecting}\n          onClick={handleClickOnMemoryCell}\n        />\n      </div>\n    </MemoryWrapper>\n\n  );\n}","import { useNeander } from \"./useNeader\"\n\nexport default function useBitComplement(size: number=8){\n  const {bitComplement} = useNeander();\n  return (value: number) => {\n    return bitComplement(value, size);\n  }\n}","import React from 'react';\nimport { ControlPanel } from './components/ControlPanel';\nimport { Instructions } from './components/Instructions';\nimport { MemoryControl } from './components/Memory/MemoryControl';\nimport { MainWrapper } from './components/styles';\nimport { NeanderCoreContext } from './NeanderCoreContext';\nimport { GlobalStyles } from './styles';\n\nconst App: React.FC = () => {\n  const version = process.env.REACT_APP_VERSION\n  return(\n    <NeanderCoreContext>\n      <GlobalStyles />\n      <h1>Neander Simulator Version {version}</h1>\n      <MainWrapper>\n        <Instructions />\n        <ControlPanel />\n        <MemoryControl />\n      </MainWrapper>\n    </NeanderCoreContext>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}