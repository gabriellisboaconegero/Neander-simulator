{"version":3,"sources":["NeanderCoreContext.tsx","useNeader.ts","components/ControlPanel.tsx","components/Header.tsx","components/Instructions.tsx","useMnemonico.ts","components/Memory/styles.ts","components/Memory/MemoryCell.tsx","components/Memory/Memory.tsx","components/Memory/MemoryControl.tsx","App.tsx","index.tsx"],"names":["OpType","MNEMONICOS","0","op","op_type","UNARY","16","BINARY","32","48","64","80","96","128","144","160","240","NeanderContext","createContext","NeanderCoreContext","children","useState","pc","setPc","ac","setAc","mem","Array","i","length","value","type","memory","setMemory","colocarSinal","flagN","setFlagN","flagZ","setFlagZ","halt","setHalt","maxDepth","depth","setDepth","number","step","localPc","op_name","next_op","prev","console","log","updateMem","op_load","addr","op_add","op_and","pos","ADDR","useEffect","contextValues","zerarAc","changeMemoryType","new_type","zerarPc","run","Provider","useNeander","useContext","ControlPanel","setAddr","className","onClick","e","htmlFor","name","id","min","onChange","parseInt","target","toString","padStart","Header","process","Instructions","Object","entries","map","op_code","useMnemonico","MemoryCellWrapper","styled","tr","props","selecting","css","MemoryCell","mem_data","showOP","showP","selected","mnemonicoParser","Memory","style","display","height","overflow","data","MemoryControl","setValue","setSelecting","setSelected","handleClickOnMemoryCell","inputRef","current","focus","select","useRef","onSubmit","preventDefault","onBlur","onKeyDown","ev","key","ref","max","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c0d96129.chunk.js","sourcesContent":["import React, { createContext, useEffect, useState } from \"react\";\n\nexport enum OpType {\n  BINARY,\n  UNARY,\n  ADDR\n}\n\nexport type MnemonicoType = {\n  [x: number]: {\n    op: string,\n    op_type: OpType\n  }\n}\n\nexport type MemoryCellType = {\n  value: number,\n  type: OpType\n}\n\n\nexport const MNEMONICOS: MnemonicoType = {\n  0:{\n   op: \"NOP\",\n   op_type: OpType.UNARY\n  },\n  16:{\n   op: \"STA\",\n   op_type: OpType.BINARY\n  },\n  32:{\n   op: \"LDA\",\n   op_type: OpType.BINARY\n  },\n  48:{\n   op: \"ADD\",\n   op_type: OpType.BINARY\n  },\n  64:{\n   op: \"OR\",\n   op_type: OpType.BINARY\n  },\n  80:{\n   op: \"AND\",\n   op_type: OpType.BINARY\n  },\n  96:{\n   op: \"NOT\",\n   op_type: OpType.UNARY\n  },\n  128:{\n   op: \"JMP\",\n   op_type: OpType.BINARY\n  },\n  144:{\n   op: \"JN\",\n   op_type: OpType.BINARY\n  },\n  160:{\n   op: \"JZ\",\n   op_type: OpType.BINARY\n  },\n  240:{\n   op: \"HLT\",\n   op_type: OpType.UNARY\n  }\n}\n\ntype NeanderContextType = {\n  ac: number;\n  pc: number;\n  memory: MemoryCellType[];\n  flagN: boolean;\n  flagZ: boolean;\n  colocarSinal: (number: number) => number;\n  step: () => void;\n  op_load: (addr: number) => void;\n  zerarAc: () => void;\n  changeMemoryType: (addr: number, new_type: OpType) => void;\n  updateMem: (addr: number, value: number) => void;\n  zerarPc: () => void;\n  run: () => void\n}\n\nexport const NeanderContext = createContext<NeanderContextType>({} as NeanderContextType);\n\nexport const NeanderCoreContext: React.FC = ({children}) => {\n\n  const [pc, setPc] = useState(0);\n  const [ac, setAc] = useState(0);\n  const [memory, setMemory] = useState(() => {\n    const mem = new Array<MemoryCellType>(256);\n    for (let i = 0; i < mem.length; i++) {\n      mem[i] = {\n        value: 0,\n        type: OpType.UNARY\n      }\n    }\n    return mem;\n  });\n  const [flagN, setFlagN] = useState(colocarSinal(ac) < 0);\n  const [flagZ, setFlagZ] = useState(ac === 0);\n\n  const [halt, setHalt] = useState(true);\n  const [maxDepth, setMaxDepth] = useState(300);\n  const [depth, setDepth] = useState(0);\n\n  useEffect(() => {\n    setFlagN(colocarSinal(ac) < 0);\n    setFlagZ(ac === 0);\n  }, [ac]);\n\n  useEffect(() => {\n    if(!halt && pc < memory.length && depth <= maxDepth){\n      step();\n      console.log(\"Dando um passo\", depth);\n    }else if(pc >= memory.length ||  depth > maxDepth){\n      setHalt(true);\n    }\n  }, [halt, pc]);\n\n  function colocarSinal(number: number): number{\n    return number >= 128? -(255 - number): number\n  }\n\n  function changeMemoryType(addr: number, new_type: OpType){\n    memory[addr].type = new_type;\n  }\n\n  function run(){\n    setHalt(false);\n  }\n\n  function step(){\n    let localPc = pc;\n    let op = memory[localPc];\n    let op_name = MNEMONICOS[(memory[localPc].value >> 4) << 4] || MNEMONICOS[0];\n    let next_op = memory[localPc + 1];\n    if (op.type ==  OpType.BINARY){\n      localPc += 2\n    }else{\n      localPc += 1;\n    }\n    setDepth(prev => prev + 1);\n\n    switch (op_name.op) {\n      case \"NOP\":\n        console.log(\"Não fez nada\")\n        break;\n      case \"STA\":\n        op_sta(next_op.value);\n        break;\n      case \"LDA\":\n        op_load(next_op.value);\n        break;\n      case \"ADD\":\n        op_add(next_op.value);\n        break;\n      case \"OR\":\n        op_or(next_op.value);\n        break;\n      case \"AND\":\n        op_and(next_op.value);\n        break;\n      case \"NOT\":\n        op_not();\n        break;\n      case \"JMP\":\n        localPc = next_op.value\n        break;\n      case \"JN\":\n        if (flagN) localPc = next_op.value\n        break;\n      case \"JZ\":\n        if (flagZ) localPc = next_op.value\n        break;\n      case \"HLT\":\n        op_hlt();\n        break;\n    \n      default:\n        break;\n    }\n    if (pc < memory.length){\n      setPc(localPc);\n    }\n  }\n\n  function op_load(addr: number){\n    setAc(memory[addr].value);\n  }\n\n  function op_sta(addr: number){\n    updateMem(addr, ac);\n  }\n\n  function op_add(addr: number){\n    setAc(prev => prev + memory[addr].value);\n  }\n\n  function op_or(value: number){\n    setAc(prev => prev | value);\n  }\n\n  function op_and(value: number){\n    setAc(prev => prev & value);\n  }\n\n  function op_not(){\n    setAc(prev => ~prev);\n  }\n\n  // function op_jmp(addr: number){   just to know that they are operations\n  //   setPc(addr);\n  // }\n\n  // function op_jn(addr: number){\n  //   if (flagN){\n  //     setPc(addr);\n  //   }\n  // }\n\n  // function op_jz(addr: number){\n  //   if (flagZ){\n  //     setPc(addr);\n  //   }\n  // }\n\n  function op_hlt(){\n    setHalt(true);\n  }\n\n  function zerarAc(){\n    setAc(0);\n  }\n\n  function zerarPc(){\n    setPc(0);\n  }\n\n  function updateMem(addr: number, value: number){\n    if (addr <  0 || addr > 255){\n      return\n    }\n    setMemory(prev => {\n      prev[addr].value = value;\n      for (let pos=addr; pos < prev.length; pos++){\n        const op = MNEMONICOS[(prev[pos].value >> 4) << 4] || MNEMONICOS[0];\n        if (pos === 0){\n          prev[pos].type = op.op_type\n        }else{\n          const prev_mem = prev[pos - 1];\n          if(prev_mem.type === OpType.BINARY){\n            prev[pos].type = OpType.ADDR\n          }else{\n            prev[pos].type = op.op_type\n          }\n        }\n        if (prev[pos].type === OpType.BINARY || pos === addr){\n          continue;\n        }\n        break\n      }\n      return [...prev]\n    });\n  }\n\n  const contextValues: NeanderContextType = {\n    ac,\n    flagN,\n    flagZ,\n    memory,\n    pc,\n    colocarSinal,\n    op_load,\n    step,\n    zerarAc,\n    changeMemoryType,\n    updateMem,\n    zerarPc,\n    run\n  }\n  return(\n    <NeanderContext.Provider value={contextValues} >\n      {children}\n    </NeanderContext.Provider >\n  );\n}","import { useContext } from \"react\";\nimport { NeanderContext } from \"./NeanderCoreContext\";\n\nexport const useNeander = () => {\n  return useContext(NeanderContext)\n}","import React, { useState } from 'react';\nimport { useNeander } from '../useNeader';\n\nexport const ControlPanel: React.FC = () => {\n  const {\n    pc,\n    ac,\n    colocarSinal,\n    flagN,\n    flagZ,\n    step,\n    zerarAc,\n    op_load,\n    zerarPc,\n    run\n  } = useNeander();\n  const [addr, setAddr] = useState(0);\n\n  function Digit3Number(number: string | number){\n    return number.toString().padStart(3, '0')\n  }\n\n  return(\n    <div>\n      <div className=\"ac_panel\">\n        <div>\n          <p>AC: {ac}</p>\n          <p>AC(Com sinal): {colocarSinal(ac)}</p>\n        </div>\n        <button onClick={e => zerarAc()} >Zerar AC</button>\n        <label htmlFor=\"set_ac\">Set Ac:</label>\n        <input \n          type=\"number\" \n          name=\"set_ac\" \n          id=\"set_ac\" \n          min=\"0\" \n          value={addr}\n          onChange={e => setAddr(parseInt(e.target.value))}\n        />\n        <button onClick={e => op_load(addr)} >Set AC</button>\n      </div>\n      <div className=\"pc_panel\">\n        <p>PC: {Digit3Number(pc)}</p>\n      </div>\n      <div className=\"flags\">\n        <span>N: {flagN? \"True\": \"False\"}</span>\n        <span>Z: {flagZ? \"True\": \"False\"}</span>\n      </div>\n      <div className=\"controls\">\n        <button onClick={e => step()} >Step</button>\n        <button onClick={e => zerarPc()} >Zerar Pc</button>\n        <button onClick={e => run()}>Run</button>\n      </div>\n    </div>\n  );\n}","import React from 'react';\n\nexport const Header: React.FC = () => {\n  const version = process.env.REACT_APP_VERSION\n  return(\n    <header>\n      <h1>Neander Simulator Version {version}</h1>\n    </header>\n  );\n}","import React from 'react';\nimport { MNEMONICOS } from '../NeanderCoreContext';\n\nexport const Instructions: React.FC = () => {\n  return(\n    <div>\n      {Object.entries(MNEMONICOS).map(([op_code, op], id) => {\n        return(\n          <p key={`instruction_map_item_${id}`}><strong>{op.op}</strong>: {op_code}</p>\n        )\n      })}\n    </div>\n  );\n}","import { MNEMONICOS } from \"./NeanderCoreContext\";\nimport { useNeander } from \"./useNeader\";\n\nconst useMnemonico = () => {\n  const {memory} = useNeander();\n  return (addr: number ) => {\n    return MNEMONICOS[(memory[addr].value >> 4) << 4] || MNEMONICOS[0];\n  }\n}\n\nexport default useMnemonico;","import styled, { css } from \"styled-components\";\n\nexport const MemoryCellWrapper  = styled.tr<{selecting: boolean}>`\n  ${props => {\n    if (props.selecting){\n      return css`\n        background-color: lightblue;\n      `\n    }\n  }}\n`","import React, { AllHTMLAttributes } from 'react';\nimport { MemoryCellType, OpType } from '../../NeanderCoreContext';\nimport useMnemonico from '../../useMnemonico';\nimport { useNeander } from '../../useNeader';\nimport { MemoryCellWrapper } from './styles';\n\ntype Props = AllHTMLAttributes<HTMLElement> & {\n  addr: number;\n  mem_data: MemoryCellType;\n  showP?: boolean;\n  showOP?: boolean;\n  selecting: boolean\n}\n\nexport const MemoryCell: React.FC<Props> = ({\n  addr,\n  mem_data,\n  showOP,\n  showP,\n  selected,\n  selecting,\n  onClick,\n}) => {\n  const mnemonicoParser = useMnemonico();\n  const {pc, memory} = useNeander();\n\n  return(\n    <MemoryCellWrapper onClick={onClick} selecting={selected && selecting? true : false}>\n      {showP && <td>{pc === addr && \">\"}</td>}\n      <td>{addr}</td>\n      <td>{mem_data.value}</td>\n      {showOP && \n        <td>\n          {mem_data.type === OpType.ADDR? \"\" : (\n            <>\n              <span>{mnemonicoParser(addr).op} &nbsp;</span>\n              {mem_data.type === OpType.BINARY && addr < memory.length && <span>{memory[addr + 1].value}</span>}\n            </>\n          )}\n        </td>\n      }\n    </MemoryCellWrapper>\n  );\n}","import React from 'react';\nimport { useNeander } from '../../useNeader';\nimport { MemoryCell } from './MemoryCell';\n\ntype Props = {\n  showOP?: boolean;\n  showP?: boolean;\n  selected: number;\n  selecting: boolean;\n  onClick?: (addr: number)  => void;\n}\n\nexport const Memory: React.FC<Props> = ({showOP, showP, selecting, selected, onClick}) => {\n  const {\n    memory,\n  }  = useNeander();\n\n  return (\n    <table \n      style={{display: \"inline-block\", height:\"350px\", overflow:\"auto\"}}\n    >\n      <thead>\n        <tr>\n          {showP && <th>P</th>}\n          <th>Address</th>\n          <th>Data</th>\n          {showOP && <th>Operation</th>}\n        </tr>\n      </thead>\n      <tbody>\n        {memory.map((data, addr) => {\n          return(\n            <MemoryCell \n              key={`${addr}_${data.value}`} \n              mem_data={data} \n              addr={addr}\n              selected={selected === addr}\n              selecting={selecting}\n              showP={showP} \n              showOP={showOP}\n              onClick={e => onClick?.(addr)}\n            />\n          )\n        })}\n      </tbody>\n    </table>\n  );\n}","import React, { KeyboardEvent, useEffect, useRef, useState } from 'react';\nimport { useNeander } from '../../useNeader';\nimport { Memory } from './Memory';\n\n\nexport const MemoryControl: React.FC = () => {\n  const {\n    memory,\n    updateMem,\n  }  = useNeander();\n\n  const [value, setValue] = useState(0);\n  const [selecting, setSelecting] = useState(false);\n  const [selected, setSelected] = useState(0);\n\n  useEffect(() => {\n    setValue(memory[selected].value);\n    inputRef.current?.select();\n  }, [selected]);\n\n  function handleKeyDown(this: HTMLElement, ev: KeyboardEvent){\n    \n    switch (ev.key) {\n      case \"ArrowDown\":\n        setSelected(prev => {\n          return prev > memory.length? prev: prev + 1\n        });\n        ev.preventDefault();\n        break;\n\n      case \"ArrowUp\":\n        setSelected(prev => {\n          return prev <= 0? prev: prev - 1\n        });\n        ev.preventDefault();\n        break;\n    \n      default:\n        break;\n    }\n  }\n\n  function handleClickOnMemoryCell(addr: number){\n    setSelected(addr);\n    inputRef.current?.focus();\n    if (selecting) return;\n    setSelecting(true);\n    \n  }\n  const inputRef = useRef<HTMLInputElement>(null);\n  \n  return(\n    <div>\n      <form\n        onSubmit={e => {\n          e.preventDefault();\n          handleClickOnMemoryCell(selected + 1);\n          updateMem(selected, value)\n        }}\n      >\n        <Memory\n          selected={selected}\n          selecting={selecting}\n          showOP\n          showP\n          onClick={handleClickOnMemoryCell}\n        />\n        <label htmlFor=\"teste2\">Addr: {selected}</label>\n        <input\n          onBlur={e => {\n            setSelecting(false)\n          }}\n          onKeyDown={handleKeyDown}\n          ref={inputRef}\n          type=\"number\"\n          name=\"teste2\"\n          id=\"teste2\"\n          min=\"0\"\n          max=\"255\"\n          value={value}\n          onChange={e => setValue(parseInt(e.target.value))}\n        />\n        <button type=\"submit\">Set mem</button>\n      </form>\n      <Memory \n        selected={selected}\n        selecting={selecting}\n        onClick={handleClickOnMemoryCell}\n      />\n    </div>\n\n  );\n}","import React from 'react';\nimport { ControlPanel } from './components/ControlPanel';\nimport { Header } from './components/Header';\nimport { Instructions } from './components/Instructions';\nimport { MemoryControl } from './components/Memory/MemoryControl';\nimport { NeanderCoreContext } from './NeanderCoreContext';\n\nconst App: React.FC = () => {\n  return(\n    <NeanderCoreContext>\n      <Header />\n      <main>\n        <Instructions />\n        <ControlPanel />\n        <MemoryControl />\n      </main>\n    </NeanderCoreContext>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}